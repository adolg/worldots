Run `make valgrind` in `testleak/` to see the error.



PROBLEM 1:

-	XCreatePixmap causes the "direct loss" of 8 bytes, which
	indirectly loses 104 bytes.

	Even more memory is still reachable.

-	This only happens when Pixmaps are used. It does not happen
	otherwise (id est with opaque images).

-	Creating a Pixmap requires a colormap. Maybe it's the colormap
	leaking.

-	XCreatePixmap calls XrmGetStringDatabase, which causes a realloc
	to be called.

-	Maybe Valgrind gives a false positive about the memory, but
	should it really say "definitely lost" then?

	The memory usage of /usr/bin/X does not seem to increase despite
	the leaks.

-	Maybe XLib allocates something that was given as NULL pointer
	(to XpmReadFileToImage?). Maybe the leak can be fixed by giving
	a non-NULL pointer and then freeing it manually afterwards.

-	Try to remove XFreePixmap(). The valgrind output is the same.
	Is the call to XFreePixmap() completely ignored? The XLib
	documentation says the pixmap will be freed when it's no longer
	referenced. Is it used after freeing it, which somehow makes it
	hang around?

	Calling XFreePixmap several times causes a BadPixmap error,
	meaning the Pixmap is really destroyed.

	Could this be because the Pixmap is located on the X server and
	isn't freed until after the program terminates?

-	It's not because of events piling up after XCopyArea (or
	similar) being called, because:

	1.	XCopyArea and functions that generate such events are
		never called.

	2.	XSetGraphicsExposures(display, gc, False) makes the gc
		stop sending such events.

	3.	Before quitting the program, all events are removed from
		the queue, and should therefore not upset Valgrind.



PROBLEM 2:

-	A conditional jump in XcursorImageHash, that was called by
	XPutImage in this program, depends on uninitialized values for
	a conditional jump. These were created by a heap allocation by
	XpmReadFileToImage.

-	Also only happens with Pixmaps, and not with all XPM files.

-	Problem is the same with O0 and O2.



OBSERVATIONS:

-	The 90 uninitialized value errors stem from the 40/p*xpm files,
	and don't happen with any other resolution p*xpm files.

-	The amount of memory lost is the same regardless how large the
	pixmaps are (always 21446 bytes in 293 blocks still reachable).

-	8 bytes are "definitely lost". This is probably some X structure
	represented by a long. It is probably the pixmap. The pixmap is
	probably a pointer to a structure somewhere, and the pixmap is
	not properly freed.



THEORIES:

-	Event is generated by XCreatePixmap, which is not handled. This
	can't be the case, but has been suggested for people with
	similar problems.

-	Feature of XLib.

	Some warnings are suppressed as "uninit padding". However,
	should that really generate Valgrind complaints? Valgrind only
	complains when the uninit values are used in some way that
	affects the execution of the program.

-	Bug in XLib.

	The uninitialized jumps may be because of an XLib bug. Why else
	would some XPM files work and some not?

-	Bug in code.

	Something isn't being freed.

-	Valgrind gives a false positive since XLib cleans it up after
	the program terminates (however this does not explain the
	uninitialized jump). Still very likely because XLib apparently
	performs some garbage collection after a program built on it
	terminates.

